// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sql

import (
	"context"
	"time"

	domain "github.com/patraden/ya-practicum-go-shortly/internal/app/domain"
)

const AddURLMapping = `-- name: AddURLMapping :one
INSERT INTO shortener.urlmapping (slug, original, user_id, created_at, expires_at, deleted)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (original) DO UPDATE
SET slug = shortener.urlmapping.slug,
    user_id = shortener.urlmapping.user_id,
    created_at = shortener.urlmapping.created_at,
    expires_at = shortener.urlmapping.expires_at,
    deleted = shortener.urlmapping.deleted
RETURNING slug, original, user_id, created_at, expires_at, deleted
`

type AddURLMappingParams struct {
	Slug      domain.Slug        `db:"slug"`
	Original  domain.OriginalURL `db:"original"`
	UserID    domain.UserID      `db:"user_id"`
	CreatedAt time.Time          `db:"created_at"`
	ExpiresAt time.Time          `db:"expires_at"`
	Deleted   bool               `db:"deleted"`
}

func (q *Queries) AddURLMapping(ctx context.Context, arg AddURLMappingParams) (ShortenerUrlmapping, error) {
	row := q.db.QueryRow(ctx, AddURLMapping,
		arg.Slug,
		arg.Original,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.Deleted,
	)
	var i ShortenerUrlmapping
	err := row.Scan(
		&i.Slug,
		&i.Original,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Deleted,
	)
	return i, err
}

type AddURLMappingBatchCopyParams struct {
	Slug      domain.Slug        `db:"slug"`
	Original  domain.OriginalURL `db:"original"`
	UserID    domain.UserID      `db:"user_id"`
	CreatedAt time.Time          `db:"created_at"`
	ExpiresAt time.Time          `db:"expires_at"`
	Deleted   bool               `db:"deleted"`
}

const CreateDeletedSlugTempTable = `-- name: CreateDeletedSlugTempTable :exec
CREATE TEMP TABLE urlmapping_tmp (
    slug    VARCHAR(8)  PRIMARY KEY,
    user_id UUID        NOT NULL
) ON COMMIT DROP
`

func (q *Queries) CreateDeletedSlugTempTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, CreateDeletedSlugTempTable)
	return err
}

const DeleteSlugsInTarget = `-- name: DeleteSlugsInTarget :exec
UPDATE shortener.urlmapping
SET deleted = true
FROM urlmapping_tmp
WHERE shortener.urlmapping.slug = urlmapping_tmp.slug
  AND shortener.urlmapping.user_id = urlmapping_tmp.user_id
`

func (q *Queries) DeleteSlugsInTarget(ctx context.Context) error {
	_, err := q.db.Exec(ctx, DeleteSlugsInTarget)
	return err
}

type FillDeletedSlugTempTableParams struct {
	Slug   domain.Slug   `db:"slug"`
	UserID domain.UserID `db:"user_id"`
}

const GetStats = `-- name: GetStats :one
SELECT 
  COUNT(1)::BIGINT AS CountSlugs,
  COUNT(DISTINCT user_id)::BIGINT AS CountUsers
FROM shortener.urlmapping
`

type GetStatsRow struct {
	Countslugs int64 `db:"countslugs"`
	Countusers int64 `db:"countusers"`
}

func (q *Queries) GetStats(ctx context.Context) (GetStatsRow, error) {
	row := q.db.QueryRow(ctx, GetStats)
	var i GetStatsRow
	err := row.Scan(&i.Countslugs, &i.Countusers)
	return i, err
}

const GetURLMapping = `-- name: GetURLMapping :one
SELECT slug, original, user_id, created_at, expires_at, deleted
FROM shortener.urlmapping
WHERE slug = $1
`

func (q *Queries) GetURLMapping(ctx context.Context, slug domain.Slug) (ShortenerUrlmapping, error) {
	row := q.db.QueryRow(ctx, GetURLMapping, slug)
	var i ShortenerUrlmapping
	err := row.Scan(
		&i.Slug,
		&i.Original,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Deleted,
	)
	return i, err
}

const GetUserURLMappings = `-- name: GetUserURLMappings :many
SELECT slug, original, user_id, created_at, expires_at, deleted
FROM shortener.urlmapping
WHERE user_id =$1
`

func (q *Queries) GetUserURLMappings(ctx context.Context, userID domain.UserID) ([]ShortenerUrlmapping, error) {
	rows, err := q.db.Query(ctx, GetUserURLMappings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShortenerUrlmapping
	for rows.Next() {
		var i ShortenerUrlmapping
		if err := rows.Scan(
			&i.Slug,
			&i.Original,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Deleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
